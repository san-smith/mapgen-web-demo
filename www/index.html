<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapGen Web Demo</title>
    <meta name="description" content="Procedural world generator in your browser">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>üó∫Ô∏è MapGen Web Demo</h1>
            <p>Procedural world generation in your browser using Rust + WASM</p>
        </header>

        <div class="main-layout">
            <!-- –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –∫–∞—Ä—Ç–∞ -->
            <div class="map-area">
                <div class="status" id="status">
                    <div class="status-icon">‚è≥</div>
                    <div class="status-text">Loading WASM module...</div>
                </div>

                <div class="canvas-container">
                    <canvas id="map-canvas"></canvas>
                    <div class="canvas-overlay" id="canvas-overlay">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Generating world... (may take 10-30 seconds)</div>
                    </div>
                </div>

                <div class="debug" id="debug"></div>

                <div class="info-panel" id="info-panel">
                    <div class="info-header">
                        <h3>Province Information</h3>
                        <button id="close-info-btn" class="close-btn">√ó</button>
                    </div>
                    <div class="info-content" id="info-content">
                        <p>Click on the map to see province details.</p>
                    </div>
                </div>
            </div>

            <!-- –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
            <div class="control-panel">
                <h2 style="margin-bottom: 20px; color: #667eea;">üéõÔ∏è World Generator</h2>

                <div class="controls">
                    <div class="control-group">
                        <label for="seed-input">
                            <span class="label-text">Seed:</span>
                            <input type="number" id="seed-input" value="42" min="0" max="4294967295">
                        </label>
                    </div>

                    <div class="control-group">
                        <label for="temp-slider">
                            <span class="label-text">Temperature:</span>
                            <input type="range" id="temp-slider" min="-1" max="1" step="0.1" value="0">
                            <span class="value-display" id="temp-value">0.0</span>
                        </label>
                    </div>

                    <div class="control-group">
                        <label for="humid-slider">
                            <span class="label-text">Humidity:</span>
                            <input type="range" id="humid-slider" min="-1" max="1" step="0.1" value="0">
                            <span class="value-display" id="humid-value">0.0</span>
                        </label>
                    </div>

                    <div class="control-group">
                        <label for="width-input">
                            <span class="label-text">Width:</span>
                            <input type="number" id="width-input" value="400" min="256" max="1024" step="64">
                        </label>
                    </div>

                    <div class="control-group">
                        <label for="height-input">
                            <span class="label-text">Height:</span>
                            <input type="number" id="height-input" value="200" min="128" max="512" step="64">
                        </label>
                    </div>

                    <button id="generate-btn" class="primary-btn">Generate World</button>
                    <button id="random-seed-btn" class="secondary-btn">üé≤ Random Seed</button>
                </div>

                <div class="layer-selector">
                    <h3 style="margin-bottom: 15px; color: #555;">üó∫Ô∏è Map Layers</h3>
                    <div class="layer-option">
                        <input type="radio" id="layer-heightmap" name="map-layer" value="heightmap" checked>
                        <label for="layer-heightmap">Heightmap</label>
                    </div>
                    <div class="layer-option">
                        <input type="radio" id="layer-biomes" name="map-layer" value="biomes">
                        <label for="layer-biomes">Biomes</label>
                    </div>
                    <div class="layer-option">
                        <input type="radio" id="layer-provinces" name="map-layer" value="provinces">
                        <label for="layer-provinces">Provinces</label>
                    </div>
                    <div class="layer-option">
                        <input type="radio" id="layer-regions" name="map-layer" value="regions">
                        <label for="layer-regions">Regions</label>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>
                Powered by <a href="https://github.com/YOUR_USERNAME/mapgen" target="_blank">mapgen</a> ‚Ä¢
                <a href="https://github.com/YOUR_USERNAME/mapgen-web-demo" target="_blank">Source Code</a>
            </p>
        </footer>
    </div>

    <script type="module">
        // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –Ω–∞—à–µ–≥–æ WASM-–º–æ–¥—É–ª—è
        import init, {
            greet,
            generate_world_with_config
        } from './mapgen.js';

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let canvas, ctx;
        let currentWorldData = null;
        const statusEl = document.getElementById('status');
        const debugEl = document.getElementById('debug');

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∑—É–º–∞
        let zoomLevel = 1.0;
        let zoomCenter = { x: 0, y: 0 };
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;

        let provinceColors = new Map();
        let regionColors = new Map();

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ü–≤–µ—Ç–∞ –ø–æ ID
        function getColorFromId(id) {
            const hash = id * 1103515245 + 12345;
            const r = (hash >> 16) % 156 + 50;
            const g = (hash >> 8) % 156 + 50;
            const b = hash % 156 + 50;
            return [r, g, b];
        }

        // –¢–µ–∫—É—â–∏–π —Å–ª–æ–π
        let currentLayer = 'heightmap';

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        async function initApp() {
            updateStatus('üü°', 'Initializing WASM module...');

            try {
                await init();
                updateStatus('üü¢', 'WASM module loaded successfully!');
                logDebug('‚úÖ WASM initialized');

                canvas = document.getElementById('map-canvas');
                ctx = canvas.getContext('2d');

                const greeting = greet('Browser');
                logDebug(`üí¨ ${greeting}`);

                // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
                setupEventListeners();
                handleResize();
                window.addEventListener('resize', handleResize);

            } catch (error) {
                updateStatus('üî¥', 'Failed to load WASM module');
                logDebug(`‚ùå WASM initialization error: ${error.message}`);
                console.error('WASM init failed:', error);
            }
        }

        function setupEventListeners() {
            // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–ª–æ—ë–≤
            document.querySelectorAll('input[name="map-layer"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    currentLayer = e.target.value;
                    logDebug(`üó∫Ô∏è Layer changed to: ${currentLayer}`);
                    if (currentWorldData) {
                        renderMap(currentWorldData);
                    }
                });
            });

            // –ü–æ–ª–∑—É–Ω–∫–∏
            document.getElementById('temp-slider').addEventListener('input', (e) => {
                document.getElementById('temp-value').textContent = parseFloat(e.target.value).toFixed(1);
            });
            document.getElementById('humid-slider').addEventListener('input', (e) => {
                document.getElementById('humid-value').textContent = parseFloat(e.target.value).toFixed(1);
            });

            // –ö–Ω–æ–ø–∫–∏
            document.getElementById('random-seed-btn').addEventListener('click', () => {
                const randomSeed = Math.floor(Math.random() * 4294967295);
                document.getElementById('seed-input').value = randomSeed;
                logDebug(`üé≤ Random seed: ${randomSeed}`);
            });

            document.getElementById('generate-btn').addEventListener('click', generateWorld);
            document.getElementById('close-info-btn').addEventListener('click', () => {
                document.getElementById('info-panel').style.display = 'none';
            });

            // –ó—É–º –∏ –∫–ª–∏–∫
            canvas.addEventListener('wheel', handleZoom);
            canvas.addEventListener('click', handleMapClick);
        }

        function handleResize() {
            if (!canvas) return;
            const container = document.querySelector('.canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            if (currentWorldData) renderMap(currentWorldData);
        }

        async function generateWorld() {
            const overlay = document.getElementById('canvas-overlay');
            overlay.style.display = 'flex';

            try {
                const config = {
                    seed: parseInt(document.getElementById('seed-input').value),
                    width: parseInt(document.getElementById('width-input').value),
                    height: parseInt(document.getElementById('height-input').value),
                    globalTemperatureOffset: parseFloat(document.getElementById('temp-slider').value),
                    globalHumidityOffset: parseFloat(document.getElementById('humid-slider').value),
                };

                // –í–∞–ª–∏–¥–∞—Ü–∏—è
                if (isNaN(config.seed) || config.seed < 0 || config.seed > 4294967295) {
                    throw new Error('Invalid seed value (must be 0-4294967295)');
                }
                if (config.width < 256 || config.width > 1024) throw new Error('Width must be 256-1024');
                if (config.height < 128 || config.height > 512) throw new Error('Height must be 128-512');

                logDebug(`üöÄ Generating world:`);
                logDebug(`   Seed: ${config.seed}, Size: ${config.width}x${config.height}`);
                logDebug(`   Temp: ${config.globalTemperatureOffset}, Humidity: ${config.globalHumidityOffset}`);

                updateStatus('‚è≥', 'Generating world...');
                const result = await generate_world_with_config(config);

                logDebug(`‚úÖ World generated: ${result.width}x${result.height}`);
                currentWorldData = result;
                renderMap(result);
                updateStatus('üü¢', `Generated! Seed: ${config.seed}`);

            } catch (error) {
                updateStatus('üî¥', 'Generation failed');
                logDebug(`‚ùå Error: ${error.message}`);
                console.error('Generation failed:', error);
                alert(`Generation failed: ${error.message}`);
            } finally {
                overlay.style.display = 'none';
            }
        }

        function renderMap(data) {
            if (!ctx || !data) return;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.save();

            const centerX = zoomCenter.x * ctx.canvas.width;
            const centerY = zoomCenter.y * ctx.canvas.height;
            ctx.translate(centerX, centerY);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-centerX, -centerY);

            switch (currentLayer) {
                case 'heightmap': renderHeightmapLayer(data); break;
                case 'biomes': renderBiomesLayer(data); break;
                case 'provinces': renderProvincesLayer(data); break;
                case 'regions': renderRegionsLayer(data); break;
            }

            ctx.restore();
        }

        function renderHeightmapLayer(data) {
            if (!data.heightmap) {
                logDebug('‚ö†Ô∏è Heightmap data missing');
                return;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = data.width;
            tempCanvas.height = data.height;

            const imgData = tempCtx.createImageData(data.width, data.height);
            const pixels = imgData.data;
            const heightValues = data.heightmap; // Float32Array

            for (let i = 0; i < heightValues.length; i++) {
                const h = heightValues[i];
                const idx = i * 4;
                const val = Math.floor(h * 255);
                pixels[idx] = val;
                pixels[idx + 1] = val;
                pixels[idx + 2] = val;
                pixels[idx + 3] = 255;
            }
            tempCtx.putImageData(imgData, 0, 0);

            const scale = Math.min(ctx.canvas.width / data.width, ctx.canvas.height / data.height);
            const scaledW = data.width * scale;
            const scaledH = data.height * scale;
            const x = (ctx.canvas.width - scaledW) / 2;
            const y = (ctx.canvas.height - scaledH) / 2;

            ctx.drawImage(tempCanvas, 0, 0, data.width, data.height, x, y, scaledW, scaledH);
            logDebug(`üé® Heightmap: ${data.width}x${data.height} ‚Üí ${scaledW.toFixed(0)}x${scaledH.toFixed(0)}`);
        }

        function renderBiomesLayer(data) {
            if (!data.biomes) {
                ctx.fillStyle = '#888';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Biomes data not available', 50, ctx.canvas.height / 2);
                return;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = data.width;
            tempCanvas.height = data.height;

            const imgData = tempCtx.createImageData(data.width, data.height);
            const pixels = imgData.data;
            const biomeValues = data.biomes; // Uint32Array

            // –¶–≤–µ—Ç–∞ –±–∏–æ–º–æ–≤ (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–µ)
            const biomeColors = [
                [0, 30, 80],    // DeepOcean
                [0, 70, 140],   // Ocean
                [120, 180, 220],// IcyOcean
                [180, 200, 220],// FrozenOcean
                [220, 230, 255],// Ice
                [200, 210, 190],// Tundra
                [80, 120, 80],  // Taiga
                [60, 140, 60],  // TemperateForest
                [30, 100, 30],  // TropicalRainforest
                [140, 190, 100],// Grassland
                [160, 150, 100],// Shrubland
                [190, 170, 100],// Savanna
                [220, 200, 150],// Desert
                [70, 110, 60],  // Swamp
                [140, 140, 140],// RockyMountain
                [200, 220, 240],// GlacialMountain
            ];

            for (let i = 0; i < biomeValues.length; i++) {
                const biomeId = biomeValues[i];
                const color = biomeColors[biomeId] || [0, 0, 0];
                const idx = i * 4;
                pixels[idx] = color[0];
                pixels[idx + 1] = color[1];
                pixels[idx + 2] = color[2];
                pixels[idx + 3] = 255;
            }
            tempCtx.putImageData(imgData, 0, 0);

            const scale = Math.min(ctx.canvas.width / data.width, ctx.canvas.height / data.height);
            const scaledW = data.width * scale;
            const scaledH = data.height * scale;
            const x = (ctx.canvas.width - scaledW) / 2;
            const y = (ctx.canvas.height - scaledH) / 2;

            ctx.drawImage(tempCanvas, 0, 0, data.width, data.height, x, y, scaledW, scaledH);
            logDebug(`üåø Biomes rendered`);
        }

        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–≤–∏–Ω—Ü–∏–π
        function renderProvincesLayer(data) {
            if (!data.provinces) {
                ctx.fillStyle = '#888';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Provinces data not available', 50, ctx.canvas.height / 2);
                return;
            }

            // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–∞–Ω–≤–∞—Å
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = data.width;
            tempCanvas.height = data.height;

            // –°–æ–∑–¥–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            const imgData = tempCtx.createImageData(data.width, data.height);
            const pixels = imgData.data;
            const provinceIds = data.provinces; // Uint32Array

            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É —Ü–≤–µ—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–≤–∏–Ω—Ü–∏–π
            provinceColors = new Map();
            for (let i = 0; i < provinceIds.length; i++) {
                const id = provinceIds[i];
                if (!provinceColors.has(id)) {
                    provinceColors.set(id, getColorFromId(id));
                }
            }

            // –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–∏–∫—Å–µ–ª–∏
            for (let i = 0; i < provinceIds.length; i++) {
                const id = provinceIds[i];
                const color = provinceColors.get(id);
                const idx = i * 4;
                pixels[idx] = color[0];
                pixels[idx + 1] = color[1];
                pixels[idx + 2] = color[2];
                pixels[idx + 3] = 255; // –ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª
            }

            tempCtx.putImageData(imgData, 0, 0);

            // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏ —Ä–∏—Å—É–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–º –∫–∞–Ω–≤–∞—Å–µ
            const scale = Math.min(ctx.canvas.width / data.width, ctx.canvas.height / data.height);
            const scaledW = data.width * scale;
            const scaledH = data.height * scale;
            const x = (ctx.canvas.width - scaledW) / 2;
            const y = (ctx.canvas.height - scaledH) / 2;

            ctx.drawImage(tempCanvas, 0, 0, data.width, data.height, x, y, scaledW, scaledH);
            logDebug(`üìç Provinces rendered: ${new Set(provinceIds).size} provinces`);
        }

        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–≥–∏–æ–Ω–æ–≤
        function renderRegionsLayer(data) {
            if (!data.regions) {
                ctx.fillStyle = '#888';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Regions data not available', 50, ctx.canvas.height / 2);
                return;
            }

            // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–∞–Ω–≤–∞—Å
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = data.width;
            tempCanvas.height = data.height;

            // –°–æ–∑–¥–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            const imgData = tempCtx.createImageData(data.width, data.height);
            const pixels = imgData.data;
            const regionIds = data.regions; // Uint32Array

            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —Ä–µ–≥–∏–æ–Ω–æ–≤
            regionColors = new Map();
            for (let i = 0; i < regionIds.length; i++) {
                const id = regionIds[i];
                if (!regionColors.has(id)) {
                    regionColors.set(id, getColorFromId(id));
                }
            }

            // –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–∏–∫—Å–µ–ª–∏
            for (let i = 0; i < regionIds.length; i++) {
                const id = regionIds[i];
                const color = regionColors.get(id);
                const idx = i * 4;
                pixels[idx] = color[0];
                pixels[idx + 1] = color[1];
                pixels[idx + 2] = color[2];
                pixels[idx + 3] = 255; // –ê–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª
            }

            tempCtx.putImageData(imgData, 0, 0);

            // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏ —Ä–∏—Å—É–µ–º –Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–º –∫–∞–Ω–≤–∞—Å–µ
            const scale = Math.min(ctx.canvas.width / data.width, ctx.canvas.height / data.height);
            const scaledW = data.width * scale;
            const scaledH = data.height * scale;
            const x = (ctx.canvas.width - scaledW) / 2;
            const y = (ctx.canvas.height - scaledH) / 2;

            ctx.drawImage(tempCanvas, 0, 0, data.width, data.height, x, y, scaledW, scaledH);
            logDebug(`üìç Regions rendered: ${new Set(regionIds).size} regions`);
        }

        function handleZoom(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoomLevel + delta));
            zoomCenter = { x: mouseX / canvas.width, y: mouseY / canvas.height };
            zoomLevel = newZoom;

            logDebug(`üîç Zoom: ${zoomLevel.toFixed(2)}x`);
            if (currentWorldData) renderMap(currentWorldData);
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –ø–æ –∫–∞—Ä—Ç–µ
        function handleMapClick(e) {
            if (!currentWorldData) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / zoomLevel;
            const y = (e.clientY - rect.top) / zoomLevel;

            logDebug(`üñ±Ô∏è Click at screen: (${x.toFixed(1)}, ${y.toFixed(1)})`);

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ —Å–∏—Å—Ç–µ–º—É –∫–∞—Ä—Ç—ã
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∫–∞—Ä—Ç—ã
            if (mapX < 0 || mapX >= currentWorldData.width || mapY < 0 || mapY >= currentWorldData.height) {
                logDebug('‚ö†Ô∏è Click outside map boundaries');
                return;
            }

            // –ù–∞–π–¥–µ–º –∏–Ω–¥–µ–∫—Å –ø–∏–∫—Å–µ–ª—è
            const index = mapY * currentWorldData.width + mapX;

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–ª–æ—è –∏ –ø–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            let provinceInfo = null;
            let regionInfo = null;

            if (currentLayer === 'provinces' && currentWorldData.provinces) {
                const provinceId = currentWorldData.provinces[index];
                provinceInfo = {
                    id: provinceId,
                    name: `Province ${provinceId}`,
                    type: "Continental",
                    area: "N/A",
                    coastal: "N/A",
                    center: { x: "N/A", y: "N/A" }
                };
            }

            if (currentLayer === 'regions' && currentWorldData.regions) {
                const regionId = currentWorldData.regions[index];
                regionInfo = {
                    id: regionId,
                    name: `Region ${regionId}`,
                    color: regionColors.get(regionId),
                    provinceCount: "N/A"
                };
            }

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            showProvinceInfo({
                ...provinceInfo,
                ...regionInfo,
                x: mapX,
                y: mapY
            });
        }

        // –ü–æ–∫–∞–∑ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ–≤–∏–Ω—Ü–∏–∏
        function showProvinceInfo(info) {
            const panel = document.getElementById('info-panel');
            const content = document.getElementById('info-content');

            let html = '';

            if (info.id !== undefined) {
                html += `<p><strong>ID:</strong> ${info.id}</p>`;
                html += `<p><strong>Coordinates:</strong> (${info.x}, ${info.y})</p>`;
            }

            if (info.name) {
                html += `<p><strong>Name:</strong> ${info.name}</p>`;
            }

            if (info.type) {
                html += `<p><strong>Type:</strong> ${info.type}</p>`;
            }

            if (info.area) {
                html += `<p><strong>Area:</strong> ${info.area} pixels</p>`;
            }

            if (info.coastal !== undefined) {
                html += `<p><strong>Coastal:</strong> ${info.coastal ? 'Yes' : 'No'}</p>`;
            }

            if (info.center) {
                html += `<p><strong>Center:</strong> (${info.center.x?.toFixed(1) || 'N/A'}, ${info.center.y?.toFixed(1) || 'N/A'})</p>`;
            }

            if (info.color) {
                const colorStr = `rgb(${info.color[0]}, ${info.color[1]}, ${info.color[2]})`;
                html += `<p><strong>Color:</strong> <span style="background: ${colorStr}; width: 20px; height: 20px; display: inline-block;"></span> ${colorStr}</p>`;
            }

            if (info.provinceCount) {
                html += `<p><strong>Provinces:</strong> ${info.provinceCount}</p>`;
            }

            if (html === '') {
                html = '<p>Click on the map to see province details.</p>';
            }

            content.innerHTML = html;
            panel.style.display = 'block';

            // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è –ø–∞–Ω–µ–ª–∏
            panel.style.opacity = 0;
            setTimeout(() => {
                panel.style.opacity = 1;
                panel.style.transform = 'translateY(0)';
            }, 10);
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function updateStatus(icon, text) {
            statusEl.querySelector('.status-icon').textContent = icon;
            statusEl.querySelector('.status-text').textContent = text;
        }

        function logDebug(message) {
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const isError = message.includes('‚ùå') || message.includes('failed');
            const color = isError ? '#dc3545' : '#28a745';
            debugEl.innerHTML += `<span style="color:${color}">[${timestamp}] ${message}</span><br>`;
            debugEl.scrollTop = debugEl.scrollHeight;
        }

        // –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>

</html>